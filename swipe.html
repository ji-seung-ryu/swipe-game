<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Gamedev Canvas Workshop</title>
        <style>
            * {
                padding: 0;
                margin: 0;
            }
            canvas {
                background: #eee;
                display: block;
                margin: 0 auto;
            }
        </style>
    </head>
    <body>
        <canvas id="myCanvas" width="480" height="320"></canvas>

        <script>
            /*var rightPressed = false;
            var leftPressed = false;
            var brickRowCount = 5;
            var brickColumnCount = 3;
            var brickWidth = 75;
            var brickHeight = 20;
            var brickPadding = 10;
            var brickOffsetTop = 30;
            var brickOffsetLeft = 30;
			*/
            /*
            var bricks = [];
            for (var c = 0; c < brickColumnCount; c++) {
                bricks[c] = [];
                for (var r = 0; r < brickRowCount; r++) {
                    bricks[c][r] = { x: 0, y: 0, status: 1 };
                }
            }*/

            /*
document.addEventListener("keydown", keyDownHandler, false);
document.addEventListener("keyup", keyUpHandler, false);
			document.addEventListener("mousemove", mouseMoveHandler, false);
			
			function mouseMoveHandler(e) {
    var relativeX = e.clientX - canvas.offsetLeft;
    if(relativeX > 0 && relativeX < canvas.width) {
        paddleX = relativeX - paddleWidth/2;
		
		console.log((Math.PI * paddleX) / canvas.width); 
    }
}

function keyDownHandler(e) {
  if(e.keyCode == 39) {
    rightPressed = true;
  }
  else if(e.keyCode == 37) {
    leftPressed = true;
  }
}
function keyUpHandler(e) {
  if(e.keyCode == 39) {
    rightPressed = false;
  }
  else if(e.keyCode == 37) {
    leftPressed = false;
  }
}
function collisionDetection() {
  for(var c=0; c<brickColumnCount; c++) {
    for(var r=0; r<brickRowCount; r++) {
      var b = bricks[c][r];
      if(b.status == 1) {
        if(x > b.x && x < b.x+brickWidth && y > b.y && y < b.y+brickHeight) {
          dy = -dy;
          b.status = 0;
        }
      }
    }
  }
}

function drawBall() {
  ctx.beginPath();
  ctx.arc(x, y, ballRadius, 0, Math.PI*2);
  ctx.fillStyle = "#0095DD";
  ctx.fill();
  ctx.closePath();
}
function drawPaddle() {
  ctx.beginPath();
  ctx.rect(paddleX, canvas.height-paddleHeight, paddleWidth, paddleHeight);
  ctx.fillStyle = "#0095DD";
  ctx.fill();
  ctx.closePath();
}
function drawBricks() {
  for(var c=0; c<brickColumnCount; c++) {
    for(var r=0; r<brickRowCount; r++) {
      if(bricks[c][r].status == 1) {
        var brickX = (r*(brickWidth+brickPadding))+brickOffsetLeft;
        var brickY = (c*(brickHeight+brickPadding))+brickOffsetTop;
        bricks[c][r].x = brickX;
        bricks[c][r].y = brickY;
        ctx.beginPath();
        ctx.rect(brickX, brickY, brickWidth, brickHeight);
        ctx.fillStyle = "#0095DD";
        ctx.fill();
        ctx.closePath();
      }
    }
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBricks();
  drawBall();
  drawPaddle();
  collisionDetection();

  if(x + dx > canvas.width-ballRadius || x + dx < ballRadius) {
    dx = -dx;
  }
  if(y + dy < ballRadius) {
    dy = -dy;
  }
  else if(y + dy > canvas.height-ballRadius) {
    if(x > paddleX && x < paddleX + paddleWidth) {
      dy = -dy;
    }
    else {
      alert("GAME OVER");
      document.location.reload();
    }
  }

  if(rightPressed && paddleX < canvas.width-paddleWidth) {
    paddleX += 7;
  }
  else if(leftPressed && paddleX > 0) {
    paddleX -= 7;
  }

  x += dx;
  y += dy;
}

setInterval(draw, 10);
*/

            // Non-rotated rectangle
            var canvas = document.getElementById('myCanvas');
            var ctx = canvas.getContext('2d');
            var ballRadius = 10;
            var ball_speed = 3;
           
            
            var rotated_radian = 0.1;
            var actived= false;
			var clicked = false;
			var score =10; 
            var all_ball = [];

			
            function makeStruct(names) {
                var names = names.split(' ');
                var count = names.length;
                function constructor() {
                    for (var i = 0; i < count; i++) {
                        this[names[i]] = arguments[i];
                    }
                } 
                return constructor;
            }

            var Ball = makeStruct('id x y dx dy survived');
			
			function create_ball() {
			//	console.log ("id ",id);
				console.log('rotated radian: ', rotated_radian);
				
					var dx,dy;
                    if (rotated_radian > 0) {
                        dx = -ball_speed * Math.cos(rotated_radian);
                        dy = -ball_speed * Math.sin(rotated_radian);
                    } else {
                        dx = ball_speed * Math.cos(rotated_radian);
                        dy = ball_speed * Math.sin(rotated_radian);
                    }
                    console.log('dx ', dx);
                    console.log('dy ', dy);
				
				var ball = new Ball (1,canvas.width / 2,canvas.height - ballRadius,dx,dy,1);
				all_ball.push(ball);
				
			}
			
			function move_ball(){
				all_ball.forEach(function(ball){
					if (ball.survived){
						ball.x += ball.dx;
						ball.y += ball.dy;
					}
				})
			}
            
			

            function rotate_arrow(radian) {
                var arrow_width = 100;
                var arrow_height = 20;

                ctx.fillStyle = '#eee';
                ctx.fillRect(
                    (canvas.width - arrow_width) / 2,
                    canvas.height - arrow_height,
                    arrow_width,
                    arrow_height
                );

                ctx.translate(canvas.width / 2, canvas.height - arrow_height / 2);
                ctx.rotate(radian);
                ctx.translate(-canvas.width / 2, -canvas.height + arrow_height / 2);

                // Rotated rectangle
                ctx.fillStyle = 'red';
                ctx.fillRect(
                    (canvas.width - arrow_width) / 2,
                    canvas.height - arrow_height,
                    arrow_width,
                    arrow_height
                );
                ctx.setTransform(1, 0, 0, 1, 0, 0);
            }

            document.addEventListener('mousemove', mouseMoveHandler, false);
            document.addEventListener('click', clickHandler, false);

            function mouseMoveHandler(e) {
				if (actived){
					console.log ('actived!');
					return ; 
				} 
				
                var relativeX = e.clientX - canvas.offsetLeft;
                var relativeY = e.clientY - canvas.offsetTop;

                if (
                    relativeY > canvas.height - 20 ||
                    relativeY < 0 ||
                    relativeX < 0 ||
                    relativeX > canvas.width
                )
                    return;
                var arrowX = canvas.width / 2;
                var arrowY = canvas.height - 10;

                var tan = (arrowY - relativeY) / (relativeX - arrowX);
                var theta = Math.atan(tan);

                rotated_radian = -theta;

                //		rotate_arrow(-theta);
            }

            function clickHandler(e) {
				clicked = true;
                actived = true;
            }

            function drawBalls() {
                
				all_ball.forEach (function(ball){
					ctx.beginPath();
					ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);	
					 ctx.fillStyle = '#0095DD';
                ctx.fill();
                ctx.closePath();
				})
               
            }
			
			function detect_ball(){
				all_ball.forEach(function(ball){
				if (ball.x + ball.dx > canvas.width - ballRadius || ball.x + ball.dx < ballRadius) {
                    ball.dx = -ball.dx;
                }
                if (ball.y + ball.dy < ballRadius) {
                    ball.dy = -ball.dy;
                } else if (ball.y + ball.dy > canvas.height - ballRadius) {
                    ball.survived = 0; 
                }
				})
			}
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                rotate_arrow(rotated_radian);
                drawBalls();
				detect_ball();
					
               
                 if (clicked) {				                    
                    clicked = false;
					var interval = 1000; 
					
					for (var i=0;i<score;i++){
						setTimeout(()=>create_ball(),interval*i);
					}
					
					setTimeout(function(){actived = false;
										 console.log ('active is false');}, interval*score);
					score += 1; 
                }

                move_ball();
            }

            

            setInterval(draw, 10);
        </script>
    </body>
</html>